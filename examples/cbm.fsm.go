package examples

import "fmt"

// Generated by go-fsm-generator. DO NOT EDIT.

//+++ General machine definition +++

type CBMState int

const (
	_ CBMState = iota
	Closed
	HalfOpened
	Opened
	Terminal
)

var _CBMStateMap = map[CBMState]string{
	Closed:     "Closed",
	HalfOpened: "HalfOpened",
	Opened:     "Opened",
	Terminal:   "Terminal",
}

var _CBMParsingStateMap = map[string]CBMState{
	"Closed":     Closed,
	"HalfOpened": HalfOpened,
	"Opened":     Opened,
	"Terminal":   Terminal,
}

func (s CBMState) String() string {
	return _CBMStateMap[s]
}

type CBMBehaviour interface {
	CBMClosedState
	CBMHalfOpenedState
	CBMOpenedState
}

type CBM struct {
	state CBMState
}

func NewCBM(state CBMState) *CBM {
	return &CBM{state: state}
}

func NewCBMFromString(stateStr string) (*CBM, error) {
	state, ok := _CBMParsingStateMap[stateStr]
	if !ok {
		return nil, fmt.Errorf("state unknown for CBM: %s", stateStr)
	}
	return &CBM{state: state}, nil
}

func (m *CBM) Current() CBMState {
	return m.state
}

func (m *CBM) Operate(operator CBMBehaviour) {
	for {
		switch m.state {
		case Closed:
			m.handleClosedEvent(operator.OperateClosed())
		case HalfOpened:
			m.handleHalfOpenedEvent(operator.OperateHalfOpened())
		case Opened:
			m.handleOpenedEvent(operator.OperateOpened())
		case Terminal:
			return
		}
	}
}

func (m *CBM) Visualize() string {
	return `// Definition for CBM in Graphviz format 
digraph CBM {
	Opened -> HalfOpened [label=Try];
	HalfOpened -> Closed [label=Success];
	HalfOpened -> Opened [label=Failure];
	Closed -> Terminal [label=Panic];
	Closed -> Terminal [label=Error];
	Closed -> Opened [label=Failure];
	Terminal [shape=Msquare];
}
`
}

// Handlers for state transitions

func (m *CBM) handleClosedEvent(event CBMClosedEvent) {
	switch event {
	case ClosedError:
		m.state = Terminal
	case ClosedFailure:
		m.state = Opened
	case ClosedPanic:
		m.state = Terminal
	case ClosedNoop:
	}
}

func (m *CBM) handleHalfOpenedEvent(event CBMHalfOpenedEvent) {
	switch event {
	case HalfOpenedFailure:
		m.state = Opened
	case HalfOpenedSuccess:
		m.state = Closed
	case HalfOpenedNoop:
	}
}

func (m *CBM) handleOpenedEvent(event CBMOpenedEvent) {
	switch event {
	case OpenedTry:
		m.state = HalfOpened
	case OpenedNoop:
	}
}

//--- Here we will define all events ---

//=== CBMClosedEvent definition ===

type CBMClosedEvent int

const (
	_ CBMClosedEvent = iota
	ClosedError
	ClosedFailure
	ClosedPanic
	ClosedNoop
)

var _CBMClosedEventMap = map[CBMClosedEvent]string{
	ClosedError:   "ClosedError",
	ClosedFailure: "ClosedFailure",
	ClosedPanic:   "ClosedPanic",
	ClosedNoop:    "ClosedNoop",
}

func (m CBMClosedEvent) String() string {
	return _CBMClosedEventMap[m]
}

type CBMClosedState interface {
	OperateClosed() CBMClosedEvent
}

//=== CBMHalfOpenedEvent definition ===

type CBMHalfOpenedEvent int

const (
	_ CBMHalfOpenedEvent = iota
	HalfOpenedFailure
	HalfOpenedSuccess
	HalfOpenedNoop
)

var _CBMHalfOpenedEventMap = map[CBMHalfOpenedEvent]string{
	HalfOpenedFailure: "HalfOpenedFailure",
	HalfOpenedSuccess: "HalfOpenedSuccess",
	HalfOpenedNoop:    "HalfOpenedNoop",
}

func (m CBMHalfOpenedEvent) String() string {
	return _CBMHalfOpenedEventMap[m]
}

type CBMHalfOpenedState interface {
	OperateHalfOpened() CBMHalfOpenedEvent
}

//=== CBMOpenedEvent definition ===

type CBMOpenedEvent int

const (
	_ CBMOpenedEvent = iota
	OpenedTry
	OpenedNoop
)

var _CBMOpenedEventMap = map[CBMOpenedEvent]string{
	OpenedTry:  "OpenedTry",
	OpenedNoop: "OpenedNoop",
}

func (m CBMOpenedEvent) String() string {
	return _CBMOpenedEventMap[m]
}

type CBMOpenedState interface {
	OperateOpened() CBMOpenedEvent
}
