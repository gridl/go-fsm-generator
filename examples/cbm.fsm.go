package examples

import "fmt"

// Generated by go-fsm-generator. DO NOT EDIT.

//+++ General machine definition +++

type CBMState int

const (
	_ CBMState = iota
	Closed
	Exit
	HalfOpened
	Opened
)

var _CBMStateMap = map[CBMState]string{
	Closed:     "Closed",
	Exit:       "Exit",
	HalfOpened: "HalfOpened",
	Opened:     "Opened",
}

var _CBMParsingStateMap = map[string]CBMState{
	"Closed":     Closed,
	"Exit":       Exit,
	"HalfOpened": HalfOpened,
	"Opened":     Opened,
}

func (s CBMState) String() string {
	return _CBMStateMap[s]
}

type CBMBehaviour interface {
	CBMClosedState

	CBMHalfOpenedState
	CBMOpenedState
}

type CBM struct {
	state CBMState
}

func NewCBM(state CBMState) *CBM {
	return &CBM{state: state}
}

func NewCBMFromString(stateStr string) (*CBM, error) {
	state, ok := _CBMParsingStateMap[stateStr]
	if !ok {
		return nil, fmt.Errorf("state unknown for CBM: %s", stateStr)
	}
	return &CBM{state: state}, nil
}

func (m *CBM) Current() CBMState {
	return m.state
}

func (m *CBM) Operate(operator CBMBehaviour) {
	switch m.state {
	case Closed:
		m.handleClosedEvent(operator.OperateClosed())
	case Exit:
		return
	case HalfOpened:
		m.handleHalfOpenedEvent(operator.OperateHalfOpened())
	case Opened:
		m.handleOpenedEvent(operator.OperateOpened())
	}
}

func (m *CBM) Visualize() string {
	return `// Definition for CBM in Graphviz format 
digraph CBM {
	Closed -> Opened [label=Error];
	Closed -> Exit [label=Panic];
	Exit [shape=Msquare];
	HalfOpened -> Opened [label=Failure];
	HalfOpened -> Exit [label=Panic];
	HalfOpened -> Closed [label=Success];
	Opened -> HalfOpened [label=Try];
}
`
}

// Handlers for state transitions

func (m *CBM) handleClosedEvent(event CBMClosedEvent) {
	switch event {
	case ClosedError:
		m.state = Opened
	case ClosedPanic:
		m.state = Exit
	case ClosedNoop:
	}
}

func (m *CBM) handleHalfOpenedEvent(event CBMHalfOpenedEvent) {
	switch event {
	case HalfOpenedFailure:
		m.state = Opened
	case HalfOpenedPanic:
		m.state = Exit
	case HalfOpenedSuccess:
		m.state = Closed
	case HalfOpenedNoop:
	}
}

func (m *CBM) handleOpenedEvent(event CBMOpenedEvent) {
	switch event {
	case OpenedTry:
		m.state = HalfOpened
	case OpenedNoop:
	}
}

//--- Here we will define all events ---

//=== CBMClosedEvent definition ===

type CBMClosedEvent int

const (
	_ CBMClosedEvent = iota
	ClosedError
	ClosedPanic
	ClosedNoop
)

var _CBMClosedEventMap = map[CBMClosedEvent]string{
	ClosedError: "ClosedError",
	ClosedPanic: "ClosedPanic",
	ClosedNoop:  "ClosedNoop",
}

func (m CBMClosedEvent) String() string {
	return _CBMClosedEventMap[m]
}

type CBMClosedState interface {
	OperateClosed() CBMClosedEvent
}

//=== CBMHalfOpenedEvent definition ===

type CBMHalfOpenedEvent int

const (
	_ CBMHalfOpenedEvent = iota
	HalfOpenedFailure
	HalfOpenedPanic
	HalfOpenedSuccess
	HalfOpenedNoop
)

var _CBMHalfOpenedEventMap = map[CBMHalfOpenedEvent]string{
	HalfOpenedFailure: "HalfOpenedFailure",
	HalfOpenedPanic:   "HalfOpenedPanic",
	HalfOpenedSuccess: "HalfOpenedSuccess",
	HalfOpenedNoop:    "HalfOpenedNoop",
}

func (m CBMHalfOpenedEvent) String() string {
	return _CBMHalfOpenedEventMap[m]
}

type CBMHalfOpenedState interface {
	OperateHalfOpened() CBMHalfOpenedEvent
}

//=== CBMOpenedEvent definition ===

type CBMOpenedEvent int

const (
	_ CBMOpenedEvent = iota
	OpenedTry
	OpenedNoop
)

var _CBMOpenedEventMap = map[CBMOpenedEvent]string{
	OpenedTry:  "OpenedTry",
	OpenedNoop: "OpenedNoop",
}

func (m CBMOpenedEvent) String() string {
	return _CBMOpenedEventMap[m]
}

type CBMOpenedState interface {
	OperateOpened() CBMOpenedEvent
}
